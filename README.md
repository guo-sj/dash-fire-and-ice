### 12/13

- 配置环境
    - Unity Editor	2022.3 LTS（长期支持版）	Unity Hub 下载（选择「鸿蒙适配版」，或安装基础版后补装鸿蒙插件） <-- OK
    - 华为 Unity 鸿蒙适配插件	1.0.5+	华为开发者联盟官网下载（鸿蒙 Unity 插件地址）
    - DevEco Studio for Mac	5.0+	华为官网下载（仅用于鸿蒙工程打包 / 签名，无需深度使用） <-- OK
    - 鸿蒙 SDK（API Version 11+）	API 11/12	DevEco Studio 内自动下载（配置路径：Preferences > Appearance & Behavior > System Settings > HarmonyOS SDK）
    - 远程调试工具	Huawei DevEco Device Tool	用于 Mac 远程连接鸿蒙真机（替代本地模拟器，苹果设备无鸿蒙模拟器）

开发流程是这样的：

unity 作为一个游戏开发引擎，我们可以把它看作是一个超级框架，提供了我们创建游戏所需要的一切能力。我们在 unity editor 中使用 C# 编写游戏，接着在 unity editor 中
去测试运行。当我们觉得 OK 后，再使用 deveco 把游戏打包，放在鸿蒙设备上运行。


- 思考创意

结果：
做一个 PPT，现场发表，包提前编好，然后可以给大家去玩，然后评分


断点：unity editor 待安装

### 12/19

好，让我们来再看一看。上周是 DevEco 和 Unity Hub 已经下载好了。接着，我们看下 Unity Editor 如何下载 <-- 已经下载了团结引擎了

```
你已经安装好团结引擎（中国版Unity）和团结Editor，接下来开发鸿蒙平台游戏的核心流程是**「团结Editor内开发游戏核心逻辑 → 配置鸿蒙适配插件 → 导出鸿蒙工程 → DevEco Studio打包HAP」**，以下是针对团结引擎的本土化适配流程，步骤更贴合国内开发环境：

### 一、前提准备：安装团结引擎的鸿蒙适配插件
团结引擎已内置对OpenHarmony（鸿蒙）的适配支持，但需手动安装专属插件（比国际版Unity更简化）：
1. 打开**Tuanjie Hub**，进入已安装的团结Editor详情页，点击「**Add Modules**」；
2. 在组件列表中勾选「**OpenHarmony Build Support**」（鸿蒙构建支持），点击「Install」完成安装；
3. 验证插件：打开团结Editor，菜单栏出现「**鸿蒙/OpenHarmony**」选项，说明插件安装成功。

### 二、步骤1：在团结Editor中开发游戏核心逻辑
团结Editor的操作与国际版Unity完全一致，你依然用**C#**编写游戏逻辑，重点注意**鸿蒙设备的适配细节**：
1. **创建鸿蒙适配的项目**
   - 打开Tuanjie Hub → 「Projects」→「New Project」；
   - 选择模板（如「2D Core」/「3D Core」），**项目名称和路径不要包含中文/特殊字符**（鸿蒙工程对路径敏感）；
   - 点击「Create」，团结Editor会自动启动并创建项目。

2. **编写游戏逻辑（C#）**
   - 按之前的方法创建C#脚本（如玩家控制、碰撞检测），核心逻辑与国际版Unity一致；
   - **鸿蒙适配关键点**：
     - 输入适配：优先用团结引擎的「**TouchInput**」接口（已适配鸿蒙触屏/手柄），避免用仅PC端的输入API；
     - 资源适配：在「Project」面板创建「OpenHarmony」文件夹，存放鸿蒙专属资源（如多分辨率贴图）；
     - 权限适配：提前在代码中声明鸿蒙所需权限（如存储、音频），示例：
       ```csharp
       using UnityEngine;
       using OpenHarmony; // 团结引擎鸿蒙命名空间

       public class PermissionManager : MonoBehaviour
       {
           void Start()
           {
               // 申请鸿蒙存储权限
               OpenHarmonyPermission.RequestPermission("ohos.permission.READ_USER_STORAGE", (bool granted) => {
                   if (granted) Debug.Log("存储权限申请成功");
               });
           }
       }
       ```

3. **在Editor内测试逻辑**
   - 点击Play按钮测试游戏核心玩法（如角色移动、碰撞），确保逻辑无问题；
   - 切换到「Game」面板的「OpenHarmony Phone」模拟器（团结引擎内置），预览鸿蒙手机的显示效果。

### 三、步骤2：配置鸿蒙打包参数（团结引擎专属）
团结引擎对鸿蒙的打包配置已本土化简化，无需手动配置复杂的SDK路径：
1. 打开团结Editor → 菜单栏「**File**」→「**Build Settings**」；
2. 在平台列表中选择「**OpenHarmony**」，点击「**Switch Platform**」（切换到鸿蒙平台）；
3. 点击「**Player Settings**」，配置鸿蒙应用核心信息：
   | 配置项                | 要求                                                                 |
   |-----------------------|----------------------------------------------------------------------|
   | **Product Name**      | 与华为开发者后台的应用名称一致                                       |
   | **Package Name**      | 填写华为开发者后台的应用包名（如`com.xxx.game`，反向域名格式）|
   | **Minimum API Level** | 选择「**API 9**」（适配鸿蒙4.0+设备）|
   | **Icon/Splash**       | 上传鸿蒙应用图标/启动页（尺寸参考华为官方：108×108、192×192等）|
4. 关闭Player Settings，回到Build Settings，确认「**Scenes In Build**」已添加你的游戏场景（否则打包会黑屏）。

### 四、步骤3：导出鸿蒙工程（.ohosproj）
团结引擎可直接导出鸿蒙原生工程，无需手动修改配置：
1. 在Build Settings中点击「**Build**」，选择工程保存路径（建议新建「OpenHarmony_Project」文件夹）；
2. 等待导出完成，团结引擎会生成**鸿蒙工程文件（.ohosproj）**和游戏资源包；
3. 验证工程：打开导出的文件夹，确认包含「entry」「oh-package.json5」等鸿蒙工程核心文件。

### 五、步骤4：DevEco Studio打包鸿蒙HAP包
这一步与国际版Unity流程一致，重点是用DevEco Studio完成鸿蒙应用的签名和打包：
1. **导入鸿蒙工程**
   - 打开DevEco Studio for Mac →「File」→「Open」，选择导出的鸿蒙工程文件夹；
   - 等待工程同步完成（DevEco Studio会自动下载鸿蒙依赖包）。

2. **配置鸿蒙应用签名**
   - 登录华为开发者账号（需完成实名认证），在[华为开发者联盟](https://developer.huawei.com/consumer/cn/)创建应用并生成签名证书（.cer）和Profile文件；
   - 在DevEco Studio中配置签名：「File」→「Project Structure」→「Modules」→「Signing Config」，导入证书和Profile文件。

3. **打包HAP包**
   - 点击DevEco Studio顶部「**Build**」→「**Build HAP(s)**」→「**Build App(s)/HAP(s)**」；
   - 打包完成后，在工程的「**build/outputs/hap/debug**」目录下找到生成的HAP包（.hap）。

### 六、步骤5：部署到鸿蒙真机测试
1. 鸿蒙真机开启「开发者模式」和「USB调试」，通过数据线连接Mac；
2. 在DevEco Studio中点击顶部「**Run**」→「**Run 'entry'**」，选择连接的鸿蒙设备，自动安装HAP包；
3. 启动游戏，验证核心逻辑、触屏适配、资源加载是否正常。

### 七、团结引擎开发鸿蒙游戏的优势（本土化适配）
1. **插件简化**：内置OpenHarmony适配插件，无需手动下载华为第三方插件；
2. **资源加速**：鸿蒙专属资源通过国内CDN分发，下载更快；
3. **生态融合**：支持鸿蒙原子化服务、分布式能力等本土化特性，调用更便捷；
4. **合规性**：适配国内鸿蒙应用市场的上架规则，减少后续审核问题。

### 八、常见避坑点
1. 团结引擎的鸿蒙工程**不支持中文路径**，导出和打包时路径需全英文；
2. 鸿蒙真机测试需确保系统版本≥4.0，否则会提示“安装失败”；
3. 若游戏卡顿，在团结Editor中降低「Quality Settings」的渲染等级（如关闭抗锯齿、降低纹理分辨率）。

如果在打包或调试中遇到具体报错（如“签名配置失败”“真机安装闪退”），可以把报错信息贴出来，我会针对性给出解决方案。
```

### 使用的名称

中文名：冰火冲冲冲

英文名：Dash: Fire & Ice

### 设计文档

操作，点击即可触发角色跳跃，长按可实现二段跳（可选，用于提升操作上限）。

4. 难度递进规则：
- 基础难度（0-1000分）：状态切换频率为5-8秒/次，障碍密度低，关卡仅单一冰/火主题路段交替。
- 进阶难度（1001-3000分）：状态切换频率为3-5秒/次，障碍密度中等，出现少量“冰火混合路段”。
- 高阶难度（3001分以上）：状态切换频率为1-3秒/次，障碍密度高，以“冰火混合路段”为主，关卡移动速度提升1.5倍。

2.3 胜利与失败条件

- 失败条件：角色处于冰状态时触碰火属性障碍，或处于火状态时触碰冰属性障碍；角色掉落至关卡边界外（如悬崖、深渊）。

- 胜利条件：无尽模式下持续生存积累高分，挑战历史记录；关卡模式下到达指定终点即可通关，解锁下一关。

三、系统设计

3.1 角色系统

3.1.1 角色基础属性

属性名称

冰状态属性值

火状态属性值

说明

移动速度

基础10m/s，触发冰面滑行后15m/s

基础10m/s，触发火焰冲刺后18m/s

随难度提升同步增加，高阶难度基础速度15m/s

跳跃高度

2.5m

2.5m

二段跳高度为1.8m（叠加基础跳跃总高度4.3m）

跳跃冷却

0.5秒

0.5秒

避免连续跳跃导致操作失衡

3.1.2 状态切换机制

1. 切换触发：系统通过随机数生成器触发状态切换，切换频率随难度递进逐步缩短（对应2.2.4难度递进规则）。
2. 过渡动画：切换时播放“冻结→融化”（冰→火）或“燃烧→凝冰”（火→冰）过渡动画，时长0.2-0.3秒，避免影响跑酷操作节奏。
3. 视觉标识：角色头顶添加状态标识（冰状态为小冰锥，火状态为小火苗），屏幕左上角设置圆形状态指示器（冰状态蓝色冰晶图标，火状态红色火焰图标），切换时图标伴随缩放《冰火切换跑酷》游戏设计文档
一、文档概述
1.1 文档目的

本文档用于明确《冰火切换跑酷》游戏的核心玩法、系统设计、美术风格、技术实现要求及开发规划，为Unity开发团队提供统一的开发依据和设计标准，确保各模块开发方向一致，最终实现一款玩法独特、体验流畅的状态切换类跑酷游戏。

1.2 游戏简介

《冰火切换跑酷》是一款以“冰与火状态随机切换”为核心特色的横版2.5D跑酷游戏。玩家操控的小人会随机在冰、火两种状态间切换，需根据当前角色状态与关卡障碍属性（冰/火）的相克规则，通过点击屏幕跳跃规避危险。随着游戏进度推进，冰火状态切换频率逐渐加快，障碍密度与移动速度提升，进一步增强游戏挑战性与趣味性。

1.3 目标用户

核心用户：12-35岁喜欢休闲竞技、快节奏玩法的手游玩家；
潜在用户：跑酷游戏爱好者、对“状态切换”“元素相克”机制感兴趣的轻度游戏玩家。

1.4 核心关键词

跑酷、状态切换、冰火相克、随机挑战、快节奏、休闲竞技

二、核心玩法设计

2.1 核心循环

启动游戏→角色随机切换冰/火状态→关卡生成冰/火交替障碍→玩家观察状态与障碍属性→点击跳跃规避相克障碍→持续前进积累分数→触发状态切换频率提升→失败/通关→结算分数/开启新关卡

2.2 核心规则

1. 状态规则：角色仅存在“冰状态”“火状态”两种形态，两种状态随机切换，切换无玩家主动控制权限，仅为系统随机触发。

2. 相克规则：
- 冰状态角色：触碰“火属性障碍”（如岩浆、火焰柱）即死亡；可安全穿过“冰属性障碍”（如冰锥、冰墙），部分冰属性障碍可触发“冰面滑行”加速效果。
- 火状态角色：触碰“冰属性障碍”即死亡；可安全穿过“火属性障碍”，部分火属性障碍可触发“火焰冲刺”加速效果。

3. 操作规则：仅需“点击屏幕”单一+变色动画。

3.2 关卡系统

3.2.1 关卡主题分类

- 火焰主题路段：
- 环境元素：燃烧地面、岩浆池、火焰障碍柱、烧焦木栅栏、火山远景、暗黄色烟雾天空。
- 障碍类型：固定火焰柱（不可穿过）、移动火焰墙（左右/上下移动）、岩浆陷阱（地面塌陷触发）。
- 视觉特征：主色调为橙红、土黄、深褐，火焰障碍添加亮红色高亮效果。

- 寒冰主题路段：
- 环境元素：结冰地面、冰锥陷阱、冰墙、积雪平台、冰川远景、淡蓝色极光天空。
- 障碍类型：固定冰锥（不可穿过）、悬浮冰台（短暂存在后消失）、冰滑斜坡（触发角色滑行）。
- 视觉特征：主色调为浅蓝、冰白、深灰，冰属性障碍添加亮蓝色高亮效果。

- 冰火混合路段（高阶难度）：
- 环境元素：冰火交替地面、悬浮冰火混合平台、蒸汽升腾特效（冰火交界处）。
- 障碍类型：交替出现的冰火障碍柱、移动冰火混合墙、随机切换属性的陷阱。
- 视觉特征：冰火色调强烈对比，蒸汽特效增强视觉干扰，偶尔触发0.1秒内的屏幕模糊效果。

3.2.2 关卡生成机制

采用“程序化生成+预设路段组合”模式：
1. 基础框架：预设不同长度的冰/火/混合主题路段片段（如10m、20m、30m），系统根据难度随机组合片段生成连续关卡。
2. 障碍随机化：每个路段片段内的障碍类型、位置、移动速度随机生成，确保每次游戏体验不同。
3. 难度适配：低难度以单一主题路段为主，片段组合间隔长；高难度增加混合路段片段占比，片段组合间隔缩短，障碍生成密度提升。

3.3 计分与成就系统

3.3.1 计分规则

- 基础得分：每前进1m得10分；

- 连续生存得分：连续生存30秒额外加500分，连续生存60秒额外加1500分，以此类推；

- 技能触发得分：触发“冰面滑行”“火焰冲刺”加速效果时，每秒额外加20分；

- 难度加成：进阶难度得分×1.2倍，高阶难度得分×1.5倍。

3.3.2 成就系统

成就名称

达成条件

奖励

初入冰火

首次完成1000分

解锁基础角色皮肤（冰焰版）

极速冲刺

单次游戏触发加速效果累计10次

得分加成5%

冰火大师

在高阶难度下生存60秒

解锁稀有角色皮肤（冰晶火焰版）

无尽挑战

达成5000分

解锁无尽模式专属背景

3.4 UI系统

3.4.1 核心UI布局

- 主界面：游戏Logo、“开始游戏”“设置”“成就”“排行榜”按钮，背景为冰火混合主题动态背景；

- 游戏界面：
- 左上角：状态指示器（圆形，随角色状态切换）；
- 右上角：当前得分、距离；
- 底部中央：跳跃提示（新手引导阶段显示，后续隐藏）；
- 边缘：难度标识（基础/进阶/高阶，以颜色条区分：绿色/黄色/红色）。

- 结算界面：最终得分、历史最高分、达成成就、“重新开始”“返回主界面”按钮。

3.4.2 视觉反馈设计

- 死亡反馈：角色触碰相克障碍时，播放“冰冻碎裂”（冰状态死亡）或“火焰爆炸”（火状态死亡）动画，屏幕闪对应颜色（蓝/红）0.2秒，伴随震动反馈；

- 得分反馈：得分增加时，分数数字向上飘升后消失，大额得分（如连续生存奖励）伴随金色闪光效果；

- 状态切换反馈：切换时状态指示器缩放+变色，伴随音效（冰→火：碎裂+燃烧声；火→冰：熄灭+结冰声）。

四、美术设计

4.1 整体美术风格

采用“卡通渲染风格（Cel Shading）”，核心特点：线条清晰、色彩明快、视觉层次分明。该风格能强化冰与火的色彩对立，同时适配跑酷游戏的高速移动场景，避免复杂细节丢失，降低渲染压力。

4.2 角色美术设计

4.2.1 基础造型

Q版低多边形风格，头身比1:1.5，线条圆润，轮廓清晰。角色尺寸控制在屏幕高度的1/8-1/10，确保高速移动中玩家能快速捕捉角色状态。

4.2.2 冰火状态差异化

设计维度

冰状态

火状态

主色调

冷色系：浅蓝、冰白、淡青

暖色系：赤红、橙黄、暗焰黑

材质质感

半透明冰晶质感，边缘淡蓝色辉光，表面冰裂纹理

哑光熔岩质感，边缘橙红色火焰粒子特效，表面熔岩流淌纹理

动态特效

移动带冰晶碎屑拖尾，跳跃溅起小冰渣

移动带火焰火星拖尾，跳跃飘出小火苗

4.3 场景美术设计

4.3.1 场景层次

采用2.5D视角，背景分远、中、近三层，增强空间感：
- 远景：火山/冰川、天空、云朵，缓慢移动（速度为中景的1/3）；
- 中景：关卡主要障碍、平台，随玩家移动滚动（速度与角色移动速度一致）；
- 近景：地面纹理、角色拖尾特效、蒸汽/火星粒子，细节丰富（速度为中景的1.2倍）。

4.3.2 地面纹理区分

- 火焰路段：地面有裂纹和火星粒子，行走时产生轻微火焰跳动效果；

- 寒冰路段：地面有冰裂和反光效果，行走时产生冰渣碎屑；

- 混合路段：地面一半火焰纹理、一半寒冰纹理，交界处有蒸汽升腾特效。

4.4 特效设计规范

- 轻量性：火焰粒子、冰晶拖尾数量控制在50个以内，避免过度渲染导致掉帧；

- 辨识度：冰火特效颜色对比强烈，冰特效以蓝色系为主，火特效以红色系为主，不使用相近色；

- 时效性：状态切换过渡动画0.2-0.3秒，死亡特效0.5秒内结束，避免遮挡游戏画面影响操作。

五、技术实现

5.1 开发工具与环境

- 引擎：Unity 2022.3 LTS（长期支持版，稳定性高，适配多平台）；

- 编程语言：C#（Unity主力开发语言，适配性强）；

- 美术工具：Blender（角色/场景建模）、Substance Painter（材质绘制）、Photoshop（UI/特效绘制）；

- 目标平台：移动端（iOS/Android）、PC端（Steam休闲板块）。

5.2 核心技术模块

5.2.1 角色状态管理

采用状态模式（State Pattern）设计角色状态系统：
1. 定义BaseState基类，包含状态进入（Enter）、状态更新（Update）、状态退出（Exit）抽象方法；
2. 继承基类实现IceState、FireState子类，分别处理两种状态的移动、碰撞、特效逻辑；
3. 设计StateManager状态管理类，负责随机触发状态切换、调用状态过渡动画、更新状态指示器。

5.2.2 关卡生成系统

1. 预设路段片段：在Unity中制作不同主题（冰/火/混合）、不同长度的路段预制体，每个预制体包含环境元素和障碍占位符；
2. 程序化组合：通过C#脚本读取难度参数，随机从预制体池选取路段片段，按顺序实例化拼接成连续关卡；
3. 障碍随机化：在路段片段的障碍占位符中，随机生成不同类型、不同位置的障碍预制体，确保关卡多样性。

5.2.3 碰撞检测与物理系统

1. 角色碰撞体：为角色添加Capsule Collider胶囊碰撞体，调整大小适配角色模型；
2. 障碍碰撞体：为不同属性障碍添加Box Collider/Sphere Collider碰撞体，设置不同的Layer（冰障碍Layer、火障碍Layer）；
3. 碰撞判断：通过OnCollisionEnter2D/OnTriggerEnter2D检测角色与障碍的碰撞，根据角色当前状态和障碍Layer判断是否触发死亡逻辑。

5.2.4 性能优化

- 资源优化：对角色、场景模型进行低多边形简化，压缩纹理资源（移动端纹理尺寸不超过2048×2048）；

- 渲染优化：使用批处理（Batching）减少Draw Call，关闭不必要的实时阴影，限制粒子特效数量；

- 内存管理：采用对象池（Object Pool）复用障碍、粒子等频繁创建/销毁的对象，避免内存波动；

- 帧率稳定：锁定游戏帧率为60FPS，通过Profiler工具监控CPU/GPU占用，优化高耗时脚本逻辑。

六、开发规划

6.1 开发阶段划分

阶段

时间周期

核心任务

交付物

需求分析与原型设计

1周

明确需求边界，制作玩法原型，确认美术风格

玩法原型Demo、美术风格参考图

核心功能开发

3周

角色状态系统、基础关卡生成、碰撞检测、UI框架

可运行的核心玩法Demo

美术资源制作与整合

2周

角色模型、场景资源、特效、UI界面制作，导入Unity整合

完整美术资源包、整合后的游戏场景

系统完善与优化

2周

完善计分/成就系统，优化性能，修复Bug

性能优化后的测试版游戏

测试与上线准备

1周

内部测试、用户测试，适配多平台，准备上线材料

最终上线版游戏、上线材料包

6.2 团队分工

- 策划：1人，负责需求分析、玩法设计、系统文档撰写；

- 程序：2人，1人负责角色/状态系统，1人负责关卡生成/性能优化；

- 美术：2人，1人负责角色/场景建模，1人负责UI/特效设计；

- 测试：1人，负责功能测试、性能测试、Bug反馈。

七、风险与应对

潜在风险

影响程度

应对措施

状态切换频率过快导致玩家操作失误过多，体验变差

高

设置难度梯度缓冲，高阶难度切换频率分阶段提升；增加“状态预警”功能，切换前0.5秒状态指示器闪烁提示

程序化关卡生成出现逻辑漏洞，导致关卡卡死/无法通过

中

添加关卡合法性检测脚本，生成后自动校验障碍间距、平台高度是否合理；预留“紧急重置关卡”功能

移动端性能优化不到位，出现掉帧/卡顿

高

优先适配中低端机型，提供画质调节选项；加强粒子特效和模型面数控制，增加动态性能监控模块

美术资源制作周期超时，影响开发进度

中

制定详细的美术资源排期，优先制作核心资源（角色、基础关卡）；预留备选美术资源方案，避免单点依赖

八、附录

8.1 术语表

- 状态切换：角色在冰状态与火状态之间的随机转换；

- 相克规则：冰状态角色惧怕火障碍，火状态角色惧怕冰障碍的核心规则；

- 程序化生成：通过代码随机组合预制体生成关卡的机制；

- 对象池：复用频繁创建/销毁对象的内存管理机制。

8.2 参考资料

- 《Unity 2D游戏开发实战》

- 跑酷游戏《Subway Surfers》《Temple Run》关卡设计分析

- 卡通渲染风格游戏《原神》《塞尔达传说：旷野之息》美术参考


