### 12/13

- 配置环境
    - Unity Editor	2022.3 LTS（长期支持版）	Unity Hub 下载（选择「鸿蒙适配版」，或安装基础版后补装鸿蒙插件） <-- OK
    - 华为 Unity 鸿蒙适配插件	1.0.5+	华为开发者联盟官网下载（鸿蒙 Unity 插件地址）
    - DevEco Studio for Mac	5.0+	华为官网下载（仅用于鸿蒙工程打包 / 签名，无需深度使用） <-- OK
    - 鸿蒙 SDK（API Version 11+）	API 11/12	DevEco Studio 内自动下载（配置路径：Preferences > Appearance & Behavior > System Settings > HarmonyOS SDK）
    - 远程调试工具	Huawei DevEco Device Tool	用于 Mac 远程连接鸿蒙真机（替代本地模拟器，苹果设备无鸿蒙模拟器）

开发流程是这样的：

unity 作为一个游戏开发引擎，我们可以把它看作是一个超级框架，提供了我们创建游戏所需要的一切能力。我们在 unity editor 中使用 C# 编写游戏，接着在 unity editor 中
去测试运行。当我们觉得 OK 后，再使用 deveco 把游戏打包，放在鸿蒙设备上运行。


- 思考创意

结果：
做一个 PPT，现场发表，包提前编好，然后可以给大家去玩，然后评分


断点：unity editor 待安装

### 12/19

好，让我们来再看一看。上周是 DevEco 和 Unity Hub 已经下载好了。接着，我们看下 Unity Editor 如何下载 <-- 已经下载了团结引擎了

```
你已经安装好团结引擎（中国版Unity）和团结Editor，接下来开发鸿蒙平台游戏的核心流程是**「团结Editor内开发游戏核心逻辑 → 配置鸿蒙适配插件 → 导出鸿蒙工程 → DevEco Studio打包HAP」**，以下是针对团结引擎的本土化适配流程，步骤更贴合国内开发环境：

### 一、前提准备：安装团结引擎的鸿蒙适配插件
团结引擎已内置对OpenHarmony（鸿蒙）的适配支持，但需手动安装专属插件（比国际版Unity更简化）：
1. 打开**Tuanjie Hub**，进入已安装的团结Editor详情页，点击「**Add Modules**」；
2. 在组件列表中勾选「**OpenHarmony Build Support**」（鸿蒙构建支持），点击「Install」完成安装；
3. 验证插件：打开团结Editor，菜单栏出现「**鸿蒙/OpenHarmony**」选项，说明插件安装成功。

### 二、步骤1：在团结Editor中开发游戏核心逻辑
团结Editor的操作与国际版Unity完全一致，你依然用**C#**编写游戏逻辑，重点注意**鸿蒙设备的适配细节**：
1. **创建鸿蒙适配的项目**
   - 打开Tuanjie Hub → 「Projects」→「New Project」；
   - 选择模板（如「2D Core」/「3D Core」），**项目名称和路径不要包含中文/特殊字符**（鸿蒙工程对路径敏感）；
   - 点击「Create」，团结Editor会自动启动并创建项目。

2. **编写游戏逻辑（C#）**
   - 按之前的方法创建C#脚本（如玩家控制、碰撞检测），核心逻辑与国际版Unity一致；
   - **鸿蒙适配关键点**：
     - 输入适配：优先用团结引擎的「**TouchInput**」接口（已适配鸿蒙触屏/手柄），避免用仅PC端的输入API；
     - 资源适配：在「Project」面板创建「OpenHarmony」文件夹，存放鸿蒙专属资源（如多分辨率贴图）；
     - 权限适配：提前在代码中声明鸿蒙所需权限（如存储、音频），示例：
       ```csharp
       using UnityEngine;
       using OpenHarmony; // 团结引擎鸿蒙命名空间

       public class PermissionManager : MonoBehaviour
       {
           void Start()
           {
               // 申请鸿蒙存储权限
               OpenHarmonyPermission.RequestPermission("ohos.permission.READ_USER_STORAGE", (bool granted) => {
                   if (granted) Debug.Log("存储权限申请成功");
               });
           }
       }
       ```

3. **在Editor内测试逻辑**
   - 点击Play按钮测试游戏核心玩法（如角色移动、碰撞），确保逻辑无问题；
   - 切换到「Game」面板的「OpenHarmony Phone」模拟器（团结引擎内置），预览鸿蒙手机的显示效果。

### 三、步骤2：配置鸿蒙打包参数（团结引擎专属）
团结引擎对鸿蒙的打包配置已本土化简化，无需手动配置复杂的SDK路径：
1. 打开团结Editor → 菜单栏「**File**」→「**Build Settings**」；
2. 在平台列表中选择「**OpenHarmony**」，点击「**Switch Platform**」（切换到鸿蒙平台）；
3. 点击「**Player Settings**」，配置鸿蒙应用核心信息：
   | 配置项                | 要求                                                                 |
   |-----------------------|----------------------------------------------------------------------|
   | **Product Name**      | 与华为开发者后台的应用名称一致                                       |
   | **Package Name**      | 填写华为开发者后台的应用包名（如`com.xxx.game`，反向域名格式）|
   | **Minimum API Level** | 选择「**API 9**」（适配鸿蒙4.0+设备）|
   | **Icon/Splash**       | 上传鸿蒙应用图标/启动页（尺寸参考华为官方：108×108、192×192等）|
4. 关闭Player Settings，回到Build Settings，确认「**Scenes In Build**」已添加你的游戏场景（否则打包会黑屏）。

### 四、步骤3：导出鸿蒙工程（.ohosproj）
团结引擎可直接导出鸿蒙原生工程，无需手动修改配置：
1. 在Build Settings中点击「**Build**」，选择工程保存路径（建议新建「OpenHarmony_Project」文件夹）；
2. 等待导出完成，团结引擎会生成**鸿蒙工程文件（.ohosproj）**和游戏资源包；
3. 验证工程：打开导出的文件夹，确认包含「entry」「oh-package.json5」等鸿蒙工程核心文件。

### 五、步骤4：DevEco Studio打包鸿蒙HAP包
这一步与国际版Unity流程一致，重点是用DevEco Studio完成鸿蒙应用的签名和打包：
1. **导入鸿蒙工程**
   - 打开DevEco Studio for Mac →「File」→「Open」，选择导出的鸿蒙工程文件夹；
   - 等待工程同步完成（DevEco Studio会自动下载鸿蒙依赖包）。

2. **配置鸿蒙应用签名**
   - 登录华为开发者账号（需完成实名认证），在[华为开发者联盟](https://developer.huawei.com/consumer/cn/)创建应用并生成签名证书（.cer）和Profile文件；
   - 在DevEco Studio中配置签名：「File」→「Project Structure」→「Modules」→「Signing Config」，导入证书和Profile文件。

3. **打包HAP包**
   - 点击DevEco Studio顶部「**Build**」→「**Build HAP(s)**」→「**Build App(s)/HAP(s)**」；
   - 打包完成后，在工程的「**build/outputs/hap/debug**」目录下找到生成的HAP包（.hap）。

### 六、步骤5：部署到鸿蒙真机测试
1. 鸿蒙真机开启「开发者模式」和「USB调试」，通过数据线连接Mac；
2. 在DevEco Studio中点击顶部「**Run**」→「**Run 'entry'**」，选择连接的鸿蒙设备，自动安装HAP包；
3. 启动游戏，验证核心逻辑、触屏适配、资源加载是否正常。

### 七、团结引擎开发鸿蒙游戏的优势（本土化适配）
1. **插件简化**：内置OpenHarmony适配插件，无需手动下载华为第三方插件；
2. **资源加速**：鸿蒙专属资源通过国内CDN分发，下载更快；
3. **生态融合**：支持鸿蒙原子化服务、分布式能力等本土化特性，调用更便捷；
4. **合规性**：适配国内鸿蒙应用市场的上架规则，减少后续审核问题。

### 八、常见避坑点
1. 团结引擎的鸿蒙工程**不支持中文路径**，导出和打包时路径需全英文；
2. 鸿蒙真机测试需确保系统版本≥4.0，否则会提示“安装失败”；
3. 若游戏卡顿，在团结Editor中降低「Quality Settings」的渲染等级（如关闭抗锯齿、降低纹理分辨率）。

如果在打包或调试中遇到具体报错（如“签名配置失败”“真机安装闪退”），可以把报错信息贴出来，我会针对性给出解决方案。
```

### 使用的名称

中文名：冰火冲冲冲

英文名：Dash: Fire & Ice

### 设计文档

操作，点击即可触发角色跳跃，长按可实现二段跳（可选，用于提升操作上限）。

4. 难度递进规则：
- 基础难度（0-1000分）：状态切换频率为5-8秒/次，障碍密度低，关卡仅单一冰/火主题路段交替。
- 进阶难度（1001-3000分）：状态切换频率为3-5秒/次，障碍密度中等，出现少量“冰火混合路段”。
- 高阶难度（3001分以上）：状态切换频率为1-3秒/次，障碍密度高，以“冰火混合路段”为主，关卡移动速度提升1.5倍。

2.3 胜利与失败条件

- 失败条件：角色处于冰状态时触碰火属性障碍，或处于火状态时触碰冰属性障碍；角色掉落至关卡边界外（如悬崖、深渊）。

- 胜利条件：无尽模式下持续生存积累高分，挑战历史记录；关卡模式下到达指定终点即可通关，解锁下一关。

三、系统设计

3.1 角色系统

3.1.1 角色基础属性

属性名称

冰状态属性值

火状态属性值

说明

移动速度

基础10m/s，触发冰面滑行后15m/s

基础10m/s，触发火焰冲刺后18m/s

随难度提升同步增加，高阶难度基础速度15m/s

跳跃高度

2.5m

2.5m

二段跳高度为1.8m（叠加基础跳跃总高度4.3m）

跳跃冷却

0.5秒

0.5秒

避免连续跳跃导致操作失衡

3.1.2 状态切换机制

1. 切换触发：系统通过随机数生成器触发状态切换，切换频率随难度递进逐步缩短（对应2.2.4难度递进规则）。
2. 过渡动画：切换时播放“冻结→融化”（冰→火）或“燃烧→凝冰”（火→冰）过渡动画，时长0.2-0.3秒，避免影响跑酷操作节奏。
3. 视觉标识：角色头顶添加状态标识（冰状态为小冰锥，火状态为小火苗），屏幕左上角设置圆形状态指示器（冰状态蓝色冰晶图标，火状态红色火焰图标），切换时图标伴随缩放《冰火切换跑酷》游戏设计文档
一、文档概述
1.1 文档目的

本文档用于明确《冰火切换跑酷》游戏的核心玩法、系统设计、美术风格、技术实现要求及开发规划，为Unity开发团队提供统一的开发依据和设计标准，确保各模块开发方向一致，最终实现一款玩法独特、体验流畅的状态切换类跑酷游戏。

1.2 游戏简介

《冰火切换跑酷》是一款以“冰与火状态随机切换”为核心特色的横版2.5D跑酷游戏。玩家操控的小人会随机在冰、火两种状态间切换，需根据当前角色状态与关卡障碍属性（冰/火）的相克规则，通过点击屏幕跳跃规避危险。随着游戏进度推进，冰火状态切换频率逐渐加快，障碍密度与移动速度提升，进一步增强游戏挑战性与趣味性。

1.3 目标用户

核心用户：12-35岁喜欢休闲竞技、快节奏玩法的手游玩家；
潜在用户：跑酷游戏爱好者、对“状态切换”“元素相克”机制感兴趣的轻度游戏玩家。

1.4 核心关键词

跑酷、状态切换、冰火相克、随机挑战、快节奏、休闲竞技

二、核心玩法设计

2.1 核心循环

启动游戏→角色随机切换冰/火状态→关卡生成冰/火交替障碍→玩家观察状态与障碍属性→点击跳跃规避相克障碍→持续前进积累分数→触发状态切换频率提升→失败/通关→结算分数/开启新关卡

2.2 核心规则

1. 状态规则：角色仅存在“冰状态”“火状态”两种形态，两种状态随机切换，切换无玩家主动控制权限，仅为系统随机触发。

2. 相克规则：
- 冰状态角色：触碰“火属性障碍”（如岩浆、火焰柱）即死亡；可安全穿过“冰属性障碍”（如冰锥、冰墙），部分冰属性障碍可触发“冰面滑行”加速效果。
- 火状态角色：触碰“冰属性障碍”即死亡；可安全穿过“火属性障碍”，部分火属性障碍可触发“火焰冲刺”加速效果。

3. 操作规则：仅需“点击屏幕”单一+变色动画。

3.2 关卡系统

3.2.1 关卡主题分类

- 火焰主题路段：
- 环境元素：燃烧地面、岩浆池、火焰障碍柱、烧焦木栅栏、火山远景、暗黄色烟雾天空。
- 障碍类型：固定火焰柱（不可穿过）、移动火焰墙（左右/上下移动）、岩浆陷阱（地面塌陷触发）。
- 视觉特征：主色调为橙红、土黄、深褐，火焰障碍添加亮红色高亮效果。

- 寒冰主题路段：
- 环境元素：结冰地面、冰锥陷阱、冰墙、积雪平台、冰川远景、淡蓝色极光天空。
- 障碍类型：固定冰锥（不可穿过）、悬浮冰台（短暂存在后消失）、冰滑斜坡（触发角色滑行）。
- 视觉特征：主色调为浅蓝、冰白、深灰，冰属性障碍添加亮蓝色高亮效果。

- 冰火混合路段（高阶难度）：
- 环境元素：冰火交替地面、悬浮冰火混合平台、蒸汽升腾特效（冰火交界处）。
- 障碍类型：交替出现的冰火障碍柱、移动冰火混合墙、随机切换属性的陷阱。
- 视觉特征：冰火色调强烈对比，蒸汽特效增强视觉干扰，偶尔触发0.1秒内的屏幕模糊效果。

3.2.2 关卡生成机制

采用“程序化生成+预设路段组合”模式：
1. 基础框架：预设不同长度的冰/火/混合主题路段片段（如10m、20m、30m），系统根据难度随机组合片段生成连续关卡。
2. 障碍随机化：每个路段片段内的障碍类型、位置、移动速度随机生成，确保每次游戏体验不同。
3. 难度适配：低难度以单一主题路段为主，片段组合间隔长；高难度增加混合路段片段占比，片段组合间隔缩短，障碍生成密度提升。

3.3 计分与成就系统

3.3.1 计分规则

- 基础得分：每前进1m得10分；

- 连续生存得分：连续生存30秒额外加500分，连续生存60秒额外加1500分，以此类推；

- 技能触发得分：触发“冰面滑行”“火焰冲刺”加速效果时，每秒额外加20分；

- 难度加成：进阶难度得分×1.2倍，高阶难度得分×1.5倍。

3.3.2 成就系统

成就名称

达成条件

奖励

初入冰火

首次完成1000分

解锁基础角色皮肤（冰焰版）

极速冲刺

单次游戏触发加速效果累计10次

得分加成5%

冰火大师

在高阶难度下生存60秒

解锁稀有角色皮肤（冰晶火焰版）

无尽挑战

达成5000分

解锁无尽模式专属背景

3.4 UI系统

3.4.1 核心UI布局

- 主界面：游戏Logo、“开始游戏”“设置”“成就”“排行榜”按钮，背景为冰火混合主题动态背景；

- 游戏界面：
- 左上角：状态指示器（圆形，随角色状态切换）；
- 右上角：当前得分、距离；
- 底部中央：跳跃提示（新手引导阶段显示，后续隐藏）；
- 边缘：难度标识（基础/进阶/高阶，以颜色条区分：绿色/黄色/红色）。

- 结算界面：最终得分、历史最高分、达成成就、“重新开始”“返回主界面”按钮。

3.4.2 视觉反馈设计

- 死亡反馈：角色触碰相克障碍时，播放“冰冻碎裂”（冰状态死亡）或“火焰爆炸”（火状态死亡）动画，屏幕闪对应颜色（蓝/红）0.2秒，伴随震动反馈；

- 得分反馈：得分增加时，分数数字向上飘升后消失，大额得分（如连续生存奖励）伴随金色闪光效果；

- 状态切换反馈：切换时状态指示器缩放+变色，伴随音效（冰→火：碎裂+燃烧声；火→冰：熄灭+结冰声）。

四、美术设计

4.1 整体美术风格

采用“卡通渲染风格（Cel Shading）”，核心特点：线条清晰、色彩明快、视觉层次分明。该风格能强化冰与火的色彩对立，同时适配跑酷游戏的高速移动场景，避免复杂细节丢失，降低渲染压力。

4.2 角色美术设计

4.2.1 基础造型

Q版低多边形风格，头身比1:1.5，线条圆润，轮廓清晰。角色尺寸控制在屏幕高度的1/8-1/10，确保高速移动中玩家能快速捕捉角色状态。

4.2.2 冰火状态差异化

设计维度

冰状态

火状态

主色调

冷色系：浅蓝、冰白、淡青

暖色系：赤红、橙黄、暗焰黑

材质质感

半透明冰晶质感，边缘淡蓝色辉光，表面冰裂纹理

哑光熔岩质感，边缘橙红色火焰粒子特效，表面熔岩流淌纹理

动态特效

移动带冰晶碎屑拖尾，跳跃溅起小冰渣

移动带火焰火星拖尾，跳跃飘出小火苗

4.3 场景美术设计

4.3.1 场景层次

采用2.5D视角，背景分远、中、近三层，增强空间感：
- 远景：火山/冰川、天空、云朵，缓慢移动（速度为中景的1/3）；
- 中景：关卡主要障碍、平台，随玩家移动滚动（速度与角色移动速度一致）；
- 近景：地面纹理、角色拖尾特效、蒸汽/火星粒子，细节丰富（速度为中景的1.2倍）。

4.3.2 地面纹理区分

- 火焰路段：地面有裂纹和火星粒子，行走时产生轻微火焰跳动效果；

- 寒冰路段：地面有冰裂和反光效果，行走时产生冰渣碎屑；

- 混合路段：地面一半火焰纹理、一半寒冰纹理，交界处有蒸汽升腾特效。

4.4 特效设计规范

- 轻量性：火焰粒子、冰晶拖尾数量控制在50个以内，避免过度渲染导致掉帧；

- 辨识度：冰火特效颜色对比强烈，冰特效以蓝色系为主，火特效以红色系为主，不使用相近色；

- 时效性：状态切换过渡动画0.2-0.3秒，死亡特效0.5秒内结束，避免遮挡游戏画面影响操作。

五、技术实现

5.1 开发工具与环境

- 引擎：Unity 2022.3 LTS（长期支持版，稳定性高，适配多平台）；

- 编程语言：C#（Unity主力开发语言，适配性强）；

- 美术工具：Blender（角色/场景建模）、Substance Painter（材质绘制）、Photoshop（UI/特效绘制）；

- 目标平台：移动端（iOS/Android）、PC端（Steam休闲板块）。

5.2 核心技术模块

5.2.1 角色状态管理

采用状态模式（State Pattern）设计角色状态系统：
1. 定义BaseState基类，包含状态进入（Enter）、状态更新（Update）、状态退出（Exit）抽象方法；
2. 继承基类实现IceState、FireState子类，分别处理两种状态的移动、碰撞、特效逻辑；
3. 设计StateManager状态管理类，负责随机触发状态切换、调用状态过渡动画、更新状态指示器。

5.2.2 关卡生成系统

1. 预设路段片段：在Unity中制作不同主题（冰/火/混合）、不同长度的路段预制体，每个预制体包含环境元素和障碍占位符；
2. 程序化组合：通过C#脚本读取难度参数，随机从预制体池选取路段片段，按顺序实例化拼接成连续关卡；
3. 障碍随机化：在路段片段的障碍占位符中，随机生成不同类型、不同位置的障碍预制体，确保关卡多样性。

5.2.3 碰撞检测与物理系统

1. 角色碰撞体：为角色添加Capsule Collider胶囊碰撞体，调整大小适配角色模型；
2. 障碍碰撞体：为不同属性障碍添加Box Collider/Sphere Collider碰撞体，设置不同的Layer（冰障碍Layer、火障碍Layer）；
3. 碰撞判断：通过OnCollisionEnter2D/OnTriggerEnter2D检测角色与障碍的碰撞，根据角色当前状态和障碍Layer判断是否触发死亡逻辑。

5.2.4 性能优化

- 资源优化：对角色、场景模型进行低多边形简化，压缩纹理资源（移动端纹理尺寸不超过2048×2048）；

- 渲染优化：使用批处理（Batching）减少Draw Call，关闭不必要的实时阴影，限制粒子特效数量；

- 内存管理：采用对象池（Object Pool）复用障碍、粒子等频繁创建/销毁的对象，避免内存波动；

- 帧率稳定：锁定游戏帧率为60FPS，通过Profiler工具监控CPU/GPU占用，优化高耗时脚本逻辑。

六、开发规划

6.1 开发阶段划分

阶段

时间周期

核心任务

交付物

需求分析与原型设计

1周

明确需求边界，制作玩法原型，确认美术风格

玩法原型Demo、美术风格参考图

核心功能开发

3周

角色状态系统、基础关卡生成、碰撞检测、UI框架

可运行的核心玩法Demo

美术资源制作与整合

2周

角色模型、场景资源、特效、UI界面制作，导入Unity整合

完整美术资源包、整合后的游戏场景

系统完善与优化

2周

完善计分/成就系统，优化性能，修复Bug

性能优化后的测试版游戏

测试与上线准备

1周

内部测试、用户测试，适配多平台，准备上线材料

最终上线版游戏、上线材料包

6.2 团队分工

- 策划：1人，负责需求分析、玩法设计、系统文档撰写；

- 程序：2人，1人负责角色/状态系统，1人负责关卡生成/性能优化；

- 美术：2人，1人负责角色/场景建模，1人负责UI/特效设计；

- 测试：1人，负责功能测试、性能测试、Bug反馈。

七、风险与应对

潜在风险

影响程度

应对措施

状态切换频率过快导致玩家操作失误过多，体验变差

高

设置难度梯度缓冲，高阶难度切换频率分阶段提升；增加“状态预警”功能，切换前0.5秒状态指示器闪烁提示

程序化关卡生成出现逻辑漏洞，导致关卡卡死/无法通过

中

添加关卡合法性检测脚本，生成后自动校验障碍间距、平台高度是否合理；预留“紧急重置关卡”功能

移动端性能优化不到位，出现掉帧/卡顿

高

优先适配中低端机型，提供画质调节选项；加强粒子特效和模型面数控制，增加动态性能监控模块

美术资源制作周期超时，影响开发进度

中

制定详细的美术资源排期，优先制作核心资源（角色、基础关卡）；预留备选美术资源方案，避免单点依赖

八、附录

8.1 术语表

- 状态切换：角色在冰状态与火状态之间的随机转换；

- 相克规则：冰状态角色惧怕火障碍，火状态角色惧怕冰障碍的核心规则；

- 程序化生成：通过代码随机组合预制体生成关卡的机制；

- 对象池：复用频繁创建/销毁对象的内存管理机制。

8.2 参考资料

- 《Unity 2D游戏开发实战》

- 跑酷游戏《Subway Surfers》《Temple Run》关卡设计分析

- 卡通渲染风格游戏《原神》《塞尔达传说：旷野之息》美术参考

好，我们现在已经把游戏的开发流程摸清楚了，也有了一个详细的设计文档。接下来干什么呢？我觉得，采用 SDD（Specification Driven Development） 的方式最为靠谱，怎么做呢？

1、首先我们要学习一下 SDD 的开发流程
2、把我们的设计文档转换成 SDD 的标准输入
3、使用 SDD 的方式把游戏做出来


```
# 「冰火冲冲冲 / Dash: Fire & Ice」规格文档
## 1. 核心玩法
1.1 游戏类型：2D横版无尽节奏跑酷（鸿蒙手机端）
1.2 主角机制：
    - 初始可选冰人/火人，用枚举区分Ice/Fire状态；
    - 每10秒自动切换状态，切换时触发视觉反馈；
    - 冰人：二段跳高度+0.5单位，可滑过火焰障碍，触碰冰陷阱减速50%（持续2秒）；
    - 火人：滑铲速度+20%，可融化冰陷阱，触碰火焰障碍扣1条生命。
1.3 操作规则：
    - 触屏：上滑=一段跳/二段跳，下滑=滑铲，点击=使用道具；
    - 蓝牙键盘：空格=跳跃，Left Ctrl=滑铲，数字1=使用道具。
1.4 计分与生命：
    - 初始生命3条，生命为0游戏失败；
    - 普通金币+1分，冰火专属金币+2分，节奏卡点金币+3分；
    - 基础移速8m/s，每30秒移速+0.5m/s。

## 2. 鸿蒙适配要求
2.1 分辨率：支持1080×2400、1200×2600等鸿蒙主流分辨率，UI自适应；
2.2 交互：接入鸿蒙震动API（金币轻震、状态切换强震）；
2.3 性能：稳定60帧，内存占用≤200MB。
```

我们先看看有没有人使用 sdd 创建出可用的 app 级别的产品


```
# 「冰火冲冲冲」Demo 开发任务清单
**文档说明**：本清单为Unity 2022.3 LTS开发鸿蒙2D跑酷Demo的核心任务分解，所有任务基于Unity内置资源实现，无外部依赖，完成后可直接在Unity中运行并导出鸿蒙HAP包。
**核心原则**：任务按开发流程解耦，前序任务验收通过后再执行后续任务，所有代码需添加中文注释，确保可读性。

| Task ID | 任务名称               | 任务目标                                                                 | 具体执行步骤                                                                                                                                                                                                 | 输入资源                                  | 输出成果                                                                 | 验收标准                                                                                                                                                                                                 | 依赖 Task |
|---------|------------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------|
| T1      | 项目基础配置           | 完成Unity项目的鸿蒙适配、层创建、单场景初始化，为后续开发搭建基础环境       | 1. 新建Unity 2022.3 LTS 2D项目，命名为「IceFireDashDemo」；<br>2. 切换平台至OpenHarmony（File→Build Settings→OpenHarmony→Switch Platform）；<br>3. 导入Unity Input System包（Window→Package Manager→Input System）；<br>4. 创建4个层：Player、Obstacle、Ground、UI；<br>5. 新建单场景，命名为「GameScene」，保存到Scenes目录。 | Unity 2022.3 LTS、OpenHarmony SDK          | 配置完成的Unity项目工程、GameScene场景文件 | 1. 项目平台成功切换为OpenHarmony；<br>2. Input System包导入无报错；<br>3. 4个层创建完成；<br>4. GameScene场景可正常打开，控制台无报错。| 无        |
| T2      | 启动界面开发           | 实现带「开始游戏」按钮的启动UI，支持触屏点击与缩放反馈，单场景内实现界面切换 | 1. 在GameScene中创建Canvas（Render Mode设为Screen Space - Overlay），命名为「UI_Start」；<br>2. 给Canvas添加全屏Image（深绿色，模拟山水画背景，Alpha=1）；<br>3. 在Canvas下创建Button，命名为「Btn_StartGame」，按屏幕比例设置尺寸（宽=Screen.width*0.2，高=Screen.height*0.1）；<br>4. 给Button添加缩放反馈（编写`ButtonScale.cs`脚本，按下时localScale=0.95，抬起恢复1）；<br>5. 编写`StartUIManager.cs`脚本，实现点击按钮后销毁UI_Start的逻辑。 | T1的项目工程                              | UI_Start Canvas、ButtonScale.cs、StartUIManager.cs | 1. 启动界面全屏显示，按钮居中；<br>2. 点击按钮有缩放反馈；<br>3. 点击按钮后启动界面销毁，控制台无报错；<br>4. 按钮适配不同屏幕分辨率。| T1        |
| T3      | 游戏场景搭建           | 实现滚动背景与循环地面，模拟无限跑酷的视觉效果，适配鸿蒙手机分辨率         | 1. 创建滚动背景：新建空对象「BG_Scroll」，添加2个与屏幕等宽的Sprite（Unity内置Square Sprite，浅绿+深绿渐变），命名为BG1、BG2，设置Z轴=-1；编写`BackgroundScroll.cs`脚本，实现以5m/s速度向左滚动并循环拼接；<br>2. 创建地面系统：新建地面预制体「Prefab_Ground」（浅棕色Square Sprite，高度=Screen.height*0.08），添加BoxCollider2D和静态Rigidbody2D；编写`GroundManager.cs`脚本，实现3个地面段的循环生成与回收；<br>3. 给地面分配Ground层，设置碰撞矩阵仅与Player层交互。 | T2的项目工程                              | BG_Scroll对象、Prefab_Ground预制体、BackgroundScroll.cs、GroundManager.cs | 1. 背景以5m/s平稳向左滚动，无断层；<br>2. 地面无限循环生成，无空隙；<br>3. 背景和地面适配1080×2400/1200×2600分辨率；<br>4. 控制台无报错。| T2        |
| T4      | 主角对象创建           | 创建冰人主角，添加物理组件、动画控制器与内置动画片段，实现基础动画状态     | 1. 创建主角对象「Player_Ice」，添加蓝色Square Sprite（尺寸=Screen.height*0.12×Screen.height*0.12），分配Player层；<br>2. 添加Rigidbody2D（重力缩放=2，冻结X轴旋转，无水平速度）和BoxCollider2D（与Sprite尺寸匹配）；<br>3. 创建AnimatorController「Player_Ice_Animator」，添加4个动画状态：Idle、Run、Jump、Die；<br>4. 制作动画片段：<br>   - Idle：Sprite静止，时长1秒；<br>   - Run：Sprite左右X偏移±0.1+上下Y偏移±0.05，循环，时长1秒；<br>   - Jump：Sprite向上移动+旋转15°，非循环，时长0.8秒；<br>   - Die：Sprite旋转90°+向下偏移，非循环，时长0.5秒；<br>5. 设置动画过渡条件（布尔参数：isRunning、isJumping、isDead）。 | T3的项目工程                              | Player_Ice对象、Player_Ice_Animator控制器、4个动画片段 | 1. 主角物理组件配置正确，无穿透地面问题；<br>2. Animator包含4个动画状态，过渡条件设置完成；<br>3. 动画片段预览流畅，无僵硬；<br>4. 控制台无动画相关报错。| T3        |
| T5      | 主角运动与动画逻辑     | 实现主角奔跑、跳跃的交互逻辑，以及动画状态的自动切换，适配鸿蒙触屏输入     | 1. 配置Input Actions：创建「PlayerInputActions」资源，添加「Tap」动作（绑定触屏Tap事件）；<br>2. 编写`PlayerController.cs`脚本，挂载到主角对象：<br>   - 实现触屏Tap触发跳跃（落地前仅跳一次，初速度=7m/s向上）；<br>   - 实现动画参数的自动设置（isRunning=true默认，isJumping在跳跃时为true，落地后为false）；<br>   - 限制主角水平位置为Screen.width*0.2，仅垂直移动；<br>3. 添加PlayerInput组件，绑定Input Actions与脚本回调。 | T4的项目工程                              | PlayerInputActions资源、PlayerController.cs脚本 | 1. 点击屏幕任意位置，主角触发跳跃，落地前无法二次跳跃；<br>2. 跳跃高度刚好能越过障碍，下落自然；<br>3. 动画随运动状态自动切换（奔跑→跳跃→奔跑）；<br>4. 鸿蒙触屏点击响应延迟≤50ms，控制台无报错。| T4        |
| T6      | 障碍系统开发           | 实现障碍的对象池管理、随机生成与自动回收，确保性能优化                     | 1. 创建障碍预制体「Prefab_Obstacle」，添加灰色Square Sprite（尺寸=Screen.height*0.1×Screen.height*0.1），分配Obstacle层，添加BoxCollider2D；<br>2. 编写`ObstaclePool.cs`脚本，实现5个障碍的对象池初始化；<br>3. 编写`ObstacleManager.cs`脚本，实现：<br>   - 每2-4秒从对象池取一个障碍，生成在主角右侧Screen.width*0.5~0.8位置；<br>   - 障碍以5m/s向左移动，移出屏幕左侧后回收至对象池；<br>4. 给障碍预制体添加移动脚本「ObstacleMove.cs」。 | T5的项目工程                              | Prefab_Obstacle预制体、ObstaclePool.cs、ObstacleManager.cs、ObstacleMove.cs | 1. 游戏开始后每2-4秒生成一个障碍，无重复创建/销毁；<br>2. 障碍向左移动并自动回收，对象池正常工作；<br>3. 障碍尺寸确保主角一次跳跃可越过；<br>4. 运行时内存占用≤100MB，控制台无报错。| T5        |
| T7      | 碰撞检测与游戏结束     | 实现主角与障碍的碰撞检测，以及游戏结束的视觉与逻辑表现                     | 1. 编写单例`GameManager.cs`脚本，挂载到空对象「GameManager」，管理游戏状态（运行/结束）；<br>2. 在`PlayerController.cs`中添加`OnCollisionEnter2D`方法，监听与障碍的碰撞：<br>   - 碰撞后设置isDead=true，播放死亡动画；<br>   - 调用`GameManager.Instance.GameOver()`方法；<br>3. 在`GameManager`中实现GameOver逻辑：停止背景/地面/障碍移动，禁用主角输入，在Canvas中显示「游戏结束」文字（白色，字号=Screen.height*0.05，居中）。 | T6的项目工程                              | GameManager对象、GameManager.cs（单例）、游戏结束UI文本 | 1. 主角与障碍碰撞后立即播放死亡动画，停止运动；<br>2. 背景、地面、障碍停止移动；<br>3. 屏幕中央显示「游戏结束」文字，触屏输入失效；<br>4. 控制台无碰撞检测报错。| T6        |
| T8      | 鸿蒙适配与本地运行验证 | 完成项目的分辨率适配与鸿蒙打包配置，确保在Unity编辑器和鸿蒙手机中均可运行   | 1. 优化分辨率适配：所有UI/游戏对象的尺寸均通过`Screen.width/Screen.height`计算，无固定像素硬编码；<br>2. 配置Player Settings（File→Build Settings→Player Settings）：<br>   - Product Name：IceFireDashDemo；<br>   - Package Name：com.demo.icefiredash；<br>   - Minimum API Level：API 9；<br>3. 在Unity编辑器中运行场景，验证所有功能；<br>4. 导出鸿蒙HAP包（Build→Build），选择纯英文路径保存。 | T7的项目工程                              | 可运行的Unity Demo、鸿蒙HAP安装包           | 1. Unity编辑器中运行，所有功能正常（启动→奔跑→跳跃→碰撞结束）；<br>2. 导出的HAP包可在鸿蒙4.0+手机安装（开启允许未签名应用）；<br>3. 手机运行时帧率稳定60fps，无卡顿；<br>4. 所有触屏操作响应正常。| T7        |
```

断点：好了，我们已经让豆包帮我们把代码生成了，接下来，我们需要去 tuanjie 上调一下我们的程序


你看，使用 Claude Code 生成的项目报错了。接下来我们需要耐心分析一下这个错误。

```
Assets/Scripts/PlayerController.cs(19,13): error CS0246: The type or namespace name 'PlayerInputActions' could not be found (are you missing a using directive or an assembly reference?)
```

它意思是，`PlayerInputActions` 并非 Unity 内置类，需要我手动创建 Input Action 资源并自动生成对应的 C# 包装类。

我看，我们已经生成了 `Assets/InputSystem/PlayerInputActions.inputactions`，那接下来，我们要看这个东西为什么没有生成

已经解决了。

今天，我们来看下应该如何把这个项目运行起来。

现在我们的代码已经有了。我首先要知道它的结构是怎样的。
